const express = require("express"); // Import the Express framework
const path = require("path"); // Import the path module for handling file paths
const bodyParser = require("body-parser"); // Import body-parser for parsing request bodies
const sqlite3 = require("sqlite3").verbose(); // Import sqlite3 for database interactions
const bcrypt = require("bcrypt"); // Import bcrypt for password hashing
const session = require("express-session"); // Import express-session for session management
const multer = require('multer');
const app = express(); // Create an instance of an Express application
const port = 3000; // Define the port on which the server will run

app.set("view engine", "ejs"); // Set EJS as the templating engine

app.use(express.static(path.join(__dirname, 'public')));

app.use(bodyParser.urlencoded({ extended: true })); // Parse URL-encoded bodies
app.use(bodyParser.json()); // Parse JSON bodies
const storage = multer.memoryStorage(); // Store files in memory as buffers
const upload = multer({ storage: storage });
// Initialize session middleware
app.use(
  session({
    secret: "thisismysecrctekeyfhrgfgrfrty84fwir767", // Secret key for signing the session ID cookie
    resave: false, // Prevents the session from being saved back to the session store if it wasn't modified
    saveUninitialized: true, // Forces a session that is "uninitialized" to be saved to the store
  })
);

// SQLite database initialization
const db = new sqlite3.Database("./election.db"); // Open the SQLite database

// Database schema creation
db.serialize(() => {
  db.run(
    "CREATE TABLE IF NOT EXISTS auth( id INTEGER PRIMARY KEY AUTOINCREMENT, username VARCHAR(50) NOT NULL UNIQUE, password VARCHAR(255) NOT NULL, user_id INTEGER)"
  ); // Create the auth table if it doesn't exist
  db.run(
    "CREATE TABLE IF NOT EXISTS roles( id INTEGER PRIMARY KEY AUTOINCREMENT, role VARCHAR(50) NOT NULL)"
  ); // Create the roles table if it doesn't exist
  db.run(
    "CREATE TABLE IF NOT EXISTS users( id INTEGER PRIMARY KEY AUTOINCREMENT, first_name VARCHAR(50) NOT NULL, middle_name VARCHAR(50) NULL, last_name VARCHAR(50) NOT NULL, DOB DATE NOT NULL, profile_picture BLOB NOT NULL, role_id INTEGER)"
  ); // Create the users table if it doesn't exist
  db.run(
    "CREATE TABLE IF NOT EXISTS parties( id INTEGER PRIMARY KEY AUTOINCREMENT, party VARCHAR(50) NOT NULL, logo BLOB)"
  ); // Create the parties table if it doesn't exist
  db.run(
    "CREATE TABLE IF NOT EXISTS positions( id INTEGER PRIMARY KEY AUTOINCREMENT, position VARCHAR(50) NOT NULL)"
  ); // Create the positions table if it doesn't exist
  db.run(
    "CREATE TABLE IF NOT EXISTS candidates( id INTEGER PRIMARY KEY AUTOINCREMENT, first_name VARCHAR(50) NOT NULL, middle_name VARCHAR(50) NULL, last_name VARCHAR(50) NOT NULL,  party_id INTEGER NOT NULL, position_id INTEGER NOT NULL, photo BLOB)"
  ); // Create the candidates table if it doesn't exist
  db.run(
    "CREATE TABLE IF NOT EXISTS votes( id INTEGER PRIMARY KEY AUTOINCREMENT, candidate_id INTEGER NOT NULL UNIQUE, vote INTEGER NOT NULL)"
  ); // Create the votes table if it doesn't exist
 
});



// Route to render dashboard
// Route to render dashboard
app.get("/dashboard", (req, res) => {
  if (!req.session.userId) {
    return res.redirect("/login");
  }

  // SQL query to fetch candidate data along with their votes
  const sqlCandidates = `
    SELECT candidates.*, parties.party, parties.logo, positions.position, IFNULL(votes.vote, 0) AS vote
    FROM candidates
    JOIN parties ON candidates.party_id = parties.id
    JOIN positions ON candidates.position_id = positions.id
    LEFT JOIN votes ON candidates.id = votes.candidate_id
  `;

  // Fetch total users
  db.get("SELECT COUNT(username) AS totalUsers FROM auth", [], (err, result) => {
    if (err) {
      return res.status(500).send('Error fetching total users');
    }
    const totalUsers = result.totalUsers;
    const profilePicture = req.session.profilePicture;

    // Fetch candidate data including votes
    db.all(sqlCandidates, [], (err, candidates) => {
      if (err) {
        return res.status(500).send('Error fetching candidates data');
      }

      candidates = candidates.map(candidate => {
        return {
          ...candidate,
          photo: candidate.photo.toString('base64'),
          logo: candidate.logo.toString('base64')
        };
      });

      // Render the dashboard view with candidates and vote data
      res.render("Dashboard", { totalUsers, profilePicture, candidates });
    });

  });
});




// Route to render login form
app.get("/login", (req, res) => {
  res.render("Login.ejs"); // Render the Login view
});

// Route to handle login form submission
app.post("/login", (req, res) => {
  const { username, password } = req.body;

  db.get("SELECT * FROM auth WHERE username = ?", [username], (err, user) => {
    if (err) {
      return res.status(500).send("Internal Server Error");
    }
    if (!user) {
      return res.status(400).send("Invalid Username or Password");
    }

    bcrypt.compare(password, user.password, (err, result) => {
      if (result) {
        db.get("SELECT * FROM users WHERE id = ?", [user.user_id], (err, userData) => {
          if (err) {
            return res.status(500).send("Internal Server Error");
          }
          req.session.userId = user.user_id;
          req.session.profilePicture = userData.profile_picture.toString('base64'); // Convert the BLOB to base64 string
          res.redirect("/dashboard");
        });
      } else {
        res.status(400).send("Invalid Username or Password");
      }
    });
  });
});


// Route to render voters registration form
app.get("/registration", (req, res) => {
  db.all("SELECT * FROM roles", [], (err, roles) => {
    if (err) {
      return res.status(500).send('Error fetching roles');
    }
    res.render("Voter-Registration", { roles }); // Render the Voter-Registration view
  });
});

// Registration route with file upload handling
app.post('/registration', upload.single('photo'), (req, res) => {
  const { firstname, middlename, lastname, dob, username, role, password } = req.body;
  const photo = req.file ? req.file.buffer : null; // Get the file buffer

  bcrypt.hash(password, 10, (err, hashedPassword) => {
      if (err) {
          return console.error(err.message);
      }

      db.run(
          'INSERT INTO users(first_name, middle_name, last_name, DOB, profile_picture, role_id) VALUES (?,?,?,?,?,?)',
          [firstname, middlename, lastname, dob, photo, role],
          function (err) {
              if (err) {
                  return console.error(err.message);
              }
              db.run(
                  'INSERT INTO auth(username, password, user_id) VALUES (?,?,?)',
                  [username, hashedPassword, this.lastID],
                  function (err) {
                      if (err) {
                          return console.error(err.message);
                      }
                  }
              );

              console.log(`A row has been inserted with ID ${this.lastID}`);
              res.redirect('/login');
          }
      );
  });
});
// Route to render party registration form
app.get("/create/party", (req, res) => {
  res.render("Party-Registration"); // Render the Party-Registration view
});

app.post("/create/party", upload.single('logo'), (req, res) => {
  const { party } = req.body;
  const logo = req.file ? req.file.buffer : null;

  db.run(
    "INSERT INTO parties (party, logo) VALUES (?, ?)",
    [party, logo],
    function (err) {
      if (err) {
        console.error(err.message);
        return res.status(500).send('Error saving party information');
      }
      console.log(`A row has been inserted with rowid ${this.lastID}`);
      res.status(200).send('Party created successfully');
    }
  );
});


app.get("/add/position", (req, res) => {
  res.render("Position.ejs"); // Render the Position view
});

app.post("/add/position", (req, res) => {
  const { Position } = req.body; // Extract position data from request body

  db.run(
    "INSERT INTO positions (position) VALUES (?)",
    [Position],
    (err) => {
      // Insert position data into the positions table
      if (err) {
        return console.log(err.message); // Handle database errors
      }
      console.log("New record has been added"); // Log success message
      res.send("Position has been successfully added"); // Send success response
    }
  );
});

// CANDIDATE REGISTRATION ROUTES

app.get('/candidate/registration', (req, res) => {
  let partiesData, positionsData;

  db.all("SELECT * FROM parties", [], (err, parties) => {
    if (err) {
      return res.status(500).send('Error fetching parties information');
    }
    partiesData = parties;
    checkIfComplete();
  });

  db.all("SELECT * FROM positions", [], (err, positions) => {
    if (err) {
      return res.status(500).send('Error fetching positions information');
    }
    positionsData = positions;
    checkIfComplete();
  });

  function checkIfComplete() {
    if (partiesData && positionsData) {
      res.render('Candidate-Registration', { parties: partiesData, positions: positionsData });
    }
  }
});



app.post('/candidate/registration', upload.single('photo'), (req, res) => {
  const { firstname, middlename, lastname, party, position } = req.body;
  const photo = req.file ? req.file.buffer : null;

  db.run("INSERT INTO candidates (first_name, middle_name, last_name, party_id, position_id, photo) VALUES (?,?,?,?,?,?)", 
    [firstname, middlename, lastname, party, position, photo],
    function (err) {
     if (err) {
       console.error(err.message);
       res.status(500).send('Database error');
     } else {
       console.log(`A row has been inserted with rowid ${this.lastID}`);
       res.status(200).send('Success');
     }
   });
});



// ROUTE FOR USER PROFILE PAGE
// ROUTE FOR USER PROFILE PAGE
app.get('/my/profile', (req, res) => {
  if (!req.session.userId) {
    return res.redirect('/login');
  }

  const sql = `
    SELECT users.*, roles.role, auth.username
    FROM users
    JOIN roles ON users.role_id = roles.id
    JOIN auth ON users.id = auth.user_id
    WHERE users.id = ?
  `;

  db.get(sql, [req.session.userId], (err, user) => {
    if (err) {
      return res.status(500).send('An error occurred');
    }
    if (!user) {
      return res.status(404).send('User not found');
    }

    // Convert profile picture BLOB to base64 string
    user.profile_picture = user.profile_picture.toString('base64');
    res.render('Profile', { user });
  });
});


// THE MAIN ASPECT OF THE ONLINE PLATFORM, THE VOTING PROCESS

// Route to render the vote page
app.get("/vote", (req, res) => {
  if (!req.session.userId) {
    return res.redirect("/login");
  }

  // Fetch candidates and their current vote counts
  const sql = `
    SELECT candidates.id, candidates.first_name, candidates.last_name, candidates.middle_name, candidates.photo, positions.position, parties.party, IFNULL(votes.vote, 0) AS vote
    FROM candidates
    JOIN positions ON candidates.position_id = positions.id
    JOIN parties ON candidates.party_id = parties.id
    LEFT JOIN votes ON candidates.id = votes.candidate_id
  `;

  db.all(sql, [], (err, candidates) => {
    if (err) {
      return res.status(500).send("Error fetching candidates data");
    }

    // Render the voting page with the list of candidates and their votes
    res.render("vote", { candidates });
  });
});

// Route to handle voting action
app.post("/vote", (req, res) => {
  const candidateId1 = req.body.candidateId;
  const candidateId2 = req.body.candidateId2;
  const candidateId3 = req.body.candidateId3;

  const votePromises = [];

  // Function to handle voting for a specific candidate ID
  const handleVote = (candidateId) => {
    return new Promise((resolve, reject) => {
      if (!candidateId) {
        resolve(); // If no candidate is selected for this position, resolve immediately
      }

      // Check if the candidate already has votes recorded
      db.get("SELECT * FROM votes WHERE candidate_id = ?", [candidateId], (err, vote) => {
        if (err) {
          reject(err);
        }

        if (vote) {
          // Candidate has a vote record, so increment their vote count
          db.run(
            "UPDATE votes SET vote = vote + 1 WHERE candidate_id = ?",
            [candidateId],
            (err) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            }
          );
        } else {
          // No vote record, so create one with an initial vote count of 1
          db.run(
            "INSERT INTO votes (candidate_id, vote) VALUES (?, 1)",
            [candidateId],
            (err) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            }
          );
        }
      });
    });
  };

  // Add vote promises for each candidate selection
  votePromises.push(handleVote(candidateId1));
  votePromises.push(handleVote(candidateId2));
  votePromises.push(handleVote(candidateId3));

  // Wait for all vote promises to resolve
  Promise.all(votePromises)
    .then(() => {
      res.redirect("/dashboard");
    })
    .catch((err) => {
      res.status(500).send("Error processing votes");
    });
});




// logout route
app.get('/logout', (req, res) => {
  req.session.destroy(err => {
      if (err) {
          return res.status(500).send('Could not log out. Please try again.');
      }
      res.redirect('/login'); // Redirect to login page
  });
});

// Start server
app.listen(port, () => {
  console.log(`App is listening to port ${port}`); // Log message indicating server is running
});

// // Importing required modules
// const express = require("express"); // Import the Express framework
// const path = require('path');
// // Creating an instance of Express
// const app = express(); // Create an instance of an Express application
// const ejs = require('ejs');
// const exp = require("constants");
// const port = 3000; // Define the port on which the server will run

// app.use(express.static(path.join(__dirname, 'public')));
// app.use(express.json());
// app.use(express.urlencoded({extended: false}));

// app.set('view engine', 'ejs');

// const sqlite3 = require("sqlite3").verbose();
// const db = new sqlite3.Database("./election.db");

// db.serialize(() => {
//   db.run(
//     `CREATE TABLE IF NOT EXISTS auth (
//       id INTEGER PRIMARY KEY AUTOINCREMENT,
//       username TEXT UNIQUE NOT NULL,
//       password TEXT NOT NULL,
//       userId INTEGER,
//       FOREIGN KEY(userId) REFERENCES user(id)
//     )`
//   );

//   db.run(
//     `CREATE TABLE IF NOT EXISTS user (
//       id INTEGER PRIMARY KEY AUTOINCREMENT,
//       first_name TEXT NOT NULL,
//       middle_name TEXT,
//       last_name TEXT NOT NULL,
//       dob INTEGER NOT NULL,
//       role_id INTEGER,
//       party_id INTEGER,
//       photo_id INTEGER,
//       FOREIGN KEY(role_id) REFERENCES roles(id),
//       FOREIGN KEY(party_id) REFERENCES parties(id),
//       FOREIGN KEY(photo_id) REFERENCES photos(id),
//       UNIQUE(role_id, party_id, photo_id)
//     )`
//   );

//   db.run(
//     `CREATE TABLE IF NOT EXISTS roles (
//       id INTEGER PRIMARY KEY AUTOINCREMENT,
//       role TEXT NOT NULL UNIQUE
//     )`
//   );

//   db.run(
//     `CREATE TABLE IF NOT EXISTS parties (
//       id INTEGER PRIMARY KEY AUTOINCREMENT,
//       party TEXT NOT NULL UNIQUE,
//       logo BLOB NOT NULL
//     )`
//   );

//   db.run(
//     `CREATE TABLE IF NOT EXISTS positions (
//       id INTEGER PRIMARY KEY AUTOINCREMENT,
//       position TEXT NOT NULL UNIQUE
//     )`
//   );

//   db.run(
//     `CREATE TABLE IF NOT EXISTS candidate (
//       id INTEGER PRIMARY KEY AUTOINCREMENT,
//       first_name TEXT NOT NULL,
//       middle_name TEXT,
//       last_name TEXT NOT NULL,
//       party_id INTEGER NOT NULL,
//       position_id INTEGER NOT NULL,
//       photo BLOB NOT NULL,
//       FOREIGN KEY(party_id) REFERENCES parties(id),
//       FOREIGN KEY(position_id) REFERENCES positions(id),
//       UNIQUE(party_id, position_id)
//     )`
//   );

//   db.run(
//     `CREATE TABLE IF NOT EXISTS votes (
//       id INTEGER PRIMARY KEY AUTOINCREMENT,
//       candidate_id INTEGER NOT NULL,
//       votes INTEGER NOT NULL,
//       FOREIGN KEY(candidate_id) REFERENCES candidate(id)
//     )`
//   );
// });

// // db.close();
// // db.serialize(() => {
// //   const stm = db.prepare(
// //     "INSERT INTO auth (username, password) VALUES(?, ?)"
// //   );
// //   stm.run("princess", "password@123");

// //   stm.finalize();

// //   db.each("SELECT * FROM auth", (err, row) => {
// //     if (err) {
// //       console.error(err.message);
// //     } else {
// //       console.log(row);
// //     }
// //   });
// // });

// //  ROUTES
// app.get('/dashboard', (req, res) => {
//   res.render('Dashboard.ejs');
// });
// app.get('/login', (req, res) => {
//   res.render('Login.ejs');
// });
// app.get('/candidate/party-registration', (req, res) => {
//   res.render('Party-Registration.ejs');
// });
//   app.get('/registration', (req, res) => {
//     res.render('Voter-Registration.ejs');
//   });
//   app.post('/registration', (req, res) => {

//     const data = {
//       firstName: req.body.firstName,
//       middleName: req.body.lastName,
//       lastName: req.body.lastName,
//       userName: req.body.userName,
//       dob: req.body.dob,
//       photo: req.body.photo,
//       password: req.body.password
//     }
//     db.serialize(() =>{
//       const reg = db.prepare("INSERT INTO user (first_name, middle_name, last_name, dob) VALUES(?,?,?,?)");

//       reg.run(data.firstName, data.middleName, data.lastName, data.dob);

//       reg.finalize();

//       db.each("SELECT * FROM user", (err, row) => {
//         if(err) {
//           console.log(err.message);
//         }
//         else{
//           console.log(row);
//         }
//       })

//     })
//   });

// // Start the server
// app.listen(port, () => {
//   console.log(`Server running on http://localhost:${port}`); // Log a message indicating that the server is running
// });
